##### CREDIT : http://cui.unige.ch/isi/bnf/JAVA/


Arglist ::=
  Arglist | `Expression { , `Expression }

## Needs to update for One(_) here
Bit_expression ::=
  BitExpr | ( - `Expression )
  BitExpr | ( `Expression >>= `Expression` )
  BitExpr | ( `Expression >> `Expression` )
  BitExpr | ( `Expression << `Expression` )
  BitExpr | ( `Expression >>> `Expression` )

Casting_expression ::=
  Cast | ( `Type ) `Expression

Character ::=
  Char | $([^\s]*)

Class_neclaration ::=
  ClassDec | { `Modifier } class `Identifier [ extends `Class_name ] { , `Interface_name } ] "{" { `Field_declarationr } "}" 

Class_name ::=
  ClassName | `Identifier
  ClassName | ( `Package_name . `Identifier )

Compilation_unit ::=
  CompUnit | [ `Package_statement ] { `Import_statement } { `Type_declaration }

Constructor_declaration ::=
  ConstructorDec | { `Modifer } `Identifier "(" [ `Paramter_list ] ")" `Statement_block

## Needs to update for One(_) here
Creating_expression ::=
  NewExpr | new (
    ( `Class_name "(" [ `Arglist ] ")" )
    ~~OR~~ ( `Type_specifier [ "[" `Expression "]" ] { "[" "]" } )
    ~~OR~~ ( "(" `Expression ")" )
    )

Decimal_digits ::=
  ##DecDigit | $(0\.[0-9]*|[1-9][0-9]*\.[0-9]*)
  Digit | $([0-9]*)

Doc_comment ::=
  Comment | $/\*[^\*/]*\*/

Do_statement ::=
  Do | do `Statement while "(" `Expression ")" ;

Exponent_part ::=
  Exponent | e [ + ~~OR~~ - ] `Decimal_digits

Expression ::=
  NumExpr | `Numeric_expression
  TestExpr | `Testing_expression
  LogicalExpr | `Logical_expression
  StringExpr | `String_expression
  BitExpr | `Bit_expression
  CastingExpr | `Casting_expression
  Creating_Expr | `Creating_expression
  LiteralExpr | `Literal_expression
  Null | null
  Super | super
  This | this
  Identifier | `Identifier
  Expr | ( "(" `Expression ")" )
  Expr | ( `Expression
    (
    ( "(" [ `Arglist ] ")" )
    ~~OR~~ ( "[" `Expression "]" )
    ~~OR~~ ( . `Expression )
    ~~OR~~ ( , `Expression )
    ~~OR~~ ( instanceof ( `Class_name ~~OR ~~ `Interface_name ) )
    ) )

Field_declaration ::=
  FieldDec | ( [ `Doc_comment ]
    (
    `Method_declataion
    ~~OR~~ `Constructor_declaration
    ~~OR~~ `Variable_declaration
    ) )
  FieldStaticInit | `Static_initializer
  End?? | ;

Float_literal ::=
  Float | (`Decimal_digits . [ `Decimal_digits ] [ `Exponent_part ] [ `Float_type_suffix ] )
  Float | ( . `Decimal_digits [ `Exponent_part ] [ `Float_type_suffix ] )
  Float | (`Decimal_digits [ `Exponent_part ] [ `Float_type_suffix ] )

Float_type_suffix ::=
  FloatType | f
  FloatType | d

For_statement ::=
  For | for "(" ( `Variable_declaration ~~OR~~ ( `Expression ; ) ~~OR~~ ; ) [ `Expression ] ; [ `Expression ] ; ")" `Statement

Identifier ::=
  Identifier | $[A-Za-z\$_][A-Za-z0-9\$_]*

If_statement ::=
  If | if "(" `Expression ")" `Statement [ else `Statement ]

Import_statement ::=
  Import | import ( ( `Package_name . "*" ; ) ~~OR~~ ( `Class_name ~~OR~~ `Interface_name ) ) ;

Integer_literal ::=
  Integer | $([1-9][0-9]+|[0-9]*)
  HexInteger | $([0][xX][0-9A-Fa-f][0-9A-Fa-f]+)
  Integer | l

Interface_declaration ::=
  InterfaceDec | { `Modifier } interface `Identifier [ extends `Interface_name { , `Interface_name } ] "{" { `Field_declaration } "}"

Interface_name ::=
  InterfaceName | `Identifier
  InterfaceName | ( `Package_name . `Identiifer )

Literal_expression ::=
  IntegerLiteral | `Integer_literal
  FloatLiteral | `Float_literal
  String | `String
  Char | `Character

Logical_expression ::=
  Not | ( ! `Expression )
  And | ( `Expression && `Expression )
  BitAnd | ( `Expression & `Expression ) 
  AndEquals | ( `Expression &= `Expression ) 
  Or | ( `Expression || `Expression )
  BitOr | ( `Expression "|" `Expression ) 
  OrEquals | ( `Expression |= `Expression ) 
  Xor | ( `Expression "^" `Expression ) 
  XorEquals | ( `Expression ^= `Expression ) 
  Mod | (`Expression % `Expression )
  ModEquals | (`Expression %= `Expression )
  If | (`Expression ? `Expression : `Expression )
  True | true
  False | false

Method_declaration ::=
  MethodDec | { `Modifier } `Type `Identifier "(" [ `Parameter_list ] ")" { "[" "]" } ( `Statement_block ~~OR~~ ; )

Modifier ::=
  Public | public
  Private | private
  Protected | protected
  Static | static
  Final | final
  Native | native
  Synchronized | synchronized
  Abstract | abstract
  Threadsafe | threadsafe
  Transient | transient

Numberic_expression ::=
  Negative | ( - `Expression )
  Plus | ( `Expression + `Expression )
  PlusOne | ( ++ `Expression )
  PlusOne | ( `Expression ++ )
  PlusEquals | ( `Expression += `Expression )
  Minus | ( `Expression - `Expression )
  MinusOne | ( -- `Expression )
  MinusOne | ( `Expression -- )
  MinusEquals | ( `Expression -= `Expression )
  Multiply | ( `Expression * `Expression )
  MultiplyEquals | ( `Expression *= `Expression )
  Divide | ( `Expression / `Expression )
  DivideEquals | ( `Expression /= `Expression )
  Mod | ( `Expression % `Expression )
  ModEquals | ( `Expression %= `Expression )

Package_name ::=
  PackageName | `Identifier
  PackageName | ( `Package_name . `Identifier )

Package_statement ::=
  PackageStatement | package `Package_name ;

Parameter ::=
  Parameter | `Type `Identifer { "[" "]" }

Parameter_list ::=
  ParameterList | `Paramater { ,`Parameter }

Statement ::=
  VariableDec | `Variable_declaration
  Stmt | ( `Expression ; )
  StmtBlock | ( `Statement_block )
  If | ( `If_statement )
  Do | ( `Do_statement )
  While | ( `While_statement )
  For | ( `For_statement )
  Try | ( `Try_statement )
  Switch | ( `Switch_statement )
  Synchronized | ( synchronized "(" `Expression ")" `Statement )
  Return | ( return [ `Expression ] ; )
  Throw | ( throw `Expression ; )
  IdStmt | ( `Identifier : `Statement )
  Break | ( break [ `Identifier ] ; )
  Continue | ( continue [ `Identifier ] ; )
  End | ( ; )

Statement_block ::=
  StmtBlock | "{" { `Statement } "}"

Static_initializer ::= 
  Static | static `Statement_block 

String ::=
  String | $[\'[^\s]*\']

String_expression ::=
  StringConcat | ( `Expression + `Expression )
  StringConcatEquals | ( `Expression += `Expression )

Switch_statement ::= 
  Switch | switch "(" `Expression ")"
    "{" {
    ( case `Expression : )
    ~~OR~~ ( default : ) 
    ~~OR~~ `Statement
    } "}"

Testing_expression ::=
  GreaterThan | ( `Expression > `Expression )
  GreaterThanEqual | ( `Expression >= `Expression )
  LessThan | ( `Expression < `Expression )
  LessThanEqual | ( `Expression <= `Expression )
  Equal | ( `Expression == `Expression )
  NotEqual | ( `Expression != `Expression )

Try_statement ::=
  Try | try `Statement { catch "(" `Parameter ")" `Statement } [ finally `Statement }

Type ::=
  Type | `Type_specifier { "[" "]" }

Type_declaration ::=
  TypeDeclaration | [ `Doc_comment ] `Class_declaration ;
  TypeDeclaration | [ `Doc_comment ] `Interface_declaration ;

Type_specifier ::=
  Boolean | boolean
  Byte | byte
  Char | char
  Short | short
  Int | int
  Float | float
  Long | long
  Double | double
  ClassType | `Class_name
  InterfaceType | `Interface_name

Variable_declaration ::=
  VariableDec | { `Modifier } `Type `Variable_declarator { , `Variable_declarator } ;

Variable_declarator ::=
  VariableDeclarator | `Identifier { "[" "]" } [ = `Variable_initializer ]

Variable_initializer ::=
  VarInit | `Expression
  VarInit | ( "{" [ `Variable_initializer { , `Variable_initializer } [ , ] ] "}" )

While_statement ::=
  While | while "(" `Expression ")" `Statement
