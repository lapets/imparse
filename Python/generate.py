#######################################################
##
## Generate.py
##
## A cross-platform parser library.
## Generates BNF grammars into UxADT.
##
##    Web:     imparse.org
##    Version: 0.0.0.4
##
##
#######################################################

exec(open('imparse.py').read())
exec(open('genGrammar.py').read())

#######################################################
# Reads a .txt file with a grammar conforming to BNF notation
# and transforms it to UxADT

def bnfToUxadt(bnfFile):
  tokens = bnfTokenize(bnfFile)
  r = parser(grammar, tokens)
  if r is not None:
    pprint.pprint(r)
    r1 = toUxadt(r)
    return r1
  return None

def printTokens(tokens):
  c = 0
  for t in tokens:
    print(c, ' - ', t)
    c = c + 1

def bnfTokenize(bnfFile):
  bnf = open(bnfFile)

  reserved = '#\$\*\+\(\)\{\}\[\]\|' # Reserved characters 
  comment = '#[^#]+'
  #comment = '/\*[^(\*/)]+\*/'
  regExpr = '\$[^$]+\$'
  termRes = '\\\"[' + reserved + ']\\\"' # Reserved characters as terminals
  termNT = '::=|[^\s' + reserved + ']+' # Terminals and nonterminals
  #termNT = '::=|[^\s' + reserved + '][^\s]*' # Terminals and nonterminals

  regex = '|'.join([\
    comment,\
    regExpr,\
    ('[' + reserved + ']'),\
    termRes,\
    termNT,\
    ])

#  print(regex)
  regex = re.compile(regex)

  tmp = []
  for line in bnf:
    tmp = tmp + regex.findall(line)
  tokens = [t for t in tmp if not (t == None or t.isspace() or t == '')]
  bnf.close()
#  print(tokens)
  return tokens


def toUxadt(ptree):
  #print('\n')
  # Unwrap
  ps = ptree['Grammar']
  ps2 = []

  for p in ps:
    prodId = p['Production'][0]
    cs = p['Production'][1:]
    cb = []
    for c in cs:
      (label, seq) = ('', [])
      for i in range(len(c['Choice'])):
        if i == 0:
          label = c['Choice'][i]
        else:
          es = c['Choice'][i]
          r = toUxadtExpr(es)
          if r is not None:
            seq = seq + r
          else: break
      cb = cb + [Choice(label, AssocNone(), seq)]
    ps2 = ps2 + [Production(prodId, [Choices(cb)])]
  return Grammar(ps2)

def toUxadtExpr(es):
  if type(es) == str: 
    return [Terminal(es)]

  cs = []
  ty = list(es.keys())[0]
  x = es[ty][0]

  if ty == 'Comment':
    while x[0] == '#' or x[0].isspace():
      x = x[1:]
    if x[-1] == '\n':
      x = x[:-1]
    cs = cs + [Comment(x)]
  elif ty == 'Terminal':
    #x = x[1] if len(x) == 3 and x[0] == '\"' and x[-1] == '\"' else x 
    if len(x) == 3 and x[0] == '\"' and x[-1] == '\"':
      x = x[1]
    cs = cs + [Terminal(x)]
  elif ty == 'Nonterminal':
    cs = cs + [Nonterminal(x[1:])]
  elif ty == 'Empty String':
    cs = cs + [Terminal('\"\"')]
  elif ty == 'RegExpr':
    s = '/' + x[1:-1] + '/'
    cs = cs + [RegExpr(s)]
  # One/May/Many/MayMany
  elif ty == 'One':
    cs = cs + [One(toUxadtExpr(x))]
  elif ty == 'May':
    for e in es[ty]:
      cs = cs + [May(toUxadtExpr(e))]
  elif ty == 'Many':
    for e in es[ty]:
      cs = cs + [Many(toUxadtExpr(e))]
  elif ty == 'MayMany':
    for e in es[ty]:
      cs = cs + [MayMany(toUxadtExpr(e))]
  # Group
  elif ty == 'Group':
    for e in es[ty]:
      cs = cs + toUxadtExpr(e)

  return cs

#######################################
# Writes a UxADT grammar to a file
def writeUxadt(u, ret = False):
  s = uxadtToStr(u)
  f = open('eg.py', 'w')
  f.write(
"""
##########################################
##
##  UxADT grammar generated by Imparse.
##
##########################################

"""
)
  f.write('g = ')
  f.write(s)
  f.close()
  if ret:
    return s

def uxadtToStr(g, pr = False):
  ps = g.match(Grammar(_), lambda ps: ps).end
  st = 'Grammar([\\'
  for p in ps:
    (nt, cbs) = p.match(Production(_, _), lambda nt, cbs: (nt, cbs)).end
    st = st + '\n\tProduction(\'' + nt + '\', [\\'
    for cb in cbs:
      cs = cb.match(Choices(_), lambda cs: cs).end
      st = st + '\n\t\tChoices(['
      for c in cs:
        (label, seq) = c.match(Choice(_, _, _), lambda l, a, seq: (l, seq)).end
        st = st + '\n\t\t\tChoice(\'' + label + '\', AssocNone(), [\\'
        r = uxadtExprToStr(seq)
        st = st + '\n\t\t\t\t' + r + '\\\n\t\t\t\t]),\\'
      st = st + '\n\t\t\t]),\\'
    st = st + '\n\t\t]),\\'
  st = st + '\n\t])'
  if pr:
    print(st)
  return st

def uxadtExprToStr(seq):
  s = ''
  for x in seq:
    et = etype(x)
    (ty, expr) = et
 
    if ty == 'One':
      r = uxadtExprToStr(expr)
      s = s + 'One([' + r + ']), '
    elif ty == 'May':
      r = uxadtExprToStr(expr)
      s = s + 'May([' + r + ']), '
    elif ty == 'Many':
      r = uxadtExprToStr(expr)
      s = s + 'Many([' + r + ']), '
    elif ty == 'MayMany':
      r = uxadtExprToStr(expr)
      s = s + 'MayMany([' + r + ']), '
    elif ty == 'Terminal':
      s = s + 'Terminal(\'' + expr + '\'), '
    elif ty == 'RegExpr':
      s = s + 'RegExpr(\'' + expr + '\'), '
    elif ty == 'Nonterminal':
      s = s + 'Nonterminal(\'' + expr + '\'), '
  return s
  

##eof
