####################################################################
##
## Generate.py
##
## A cross-platform parser library.
## Generates BNF grammars into UxADT.
##
##    Web:     imparse.org
##    Version: 0.0.0.4
##
##

exec(open('imparse.py').read())
exec(open('genGrammar.py').read())

## RELEASE CONTENT BEGINS HERE #####################################

####################################################################
# Reads a .txt file with a grammar conforming to BNF notation
# and transforms it to UxADT.

def bnfToUxadt(bnfFile):
  tokens = bnfTokenize(bnfFile)
  r = parser(grammar, tokens)
  if r is not None:
#    pprint.pprint(r)
    r = toUxadt(r)
    return r
  return None


def bnfTokenize(bnfFile):
  bnf = open(bnfFile)

  termRes = '\\\"[' + reserved + ']\\\"' # Reserved characters as terminals
  termNT = '::=|[^\s' + reserved + ']+' # Terminals and nonterminals

  regex = '|'.join([\
    comment,\
    regExpr,\
    ('[' + reserved + ']'),\
    termRes,\
    termNT,\
    ])

  regex = re.compile(regex)

  tokens = []
  for line in bnf:
    tokens = tokens + regex.findall(line)
  tokens = [t for t in tokens if not (t == None or t.isspace() or t == '')]
  bnf.close()
#  print(tokens)
  return tokens


def toUxadt(ptree):
  # Unwrap
  ps = ptree['Grammar']
  ps2 = []

  for p in ps:
    prodId = p['Production'][0]
    cs = p['Production'][1:]
    cb = []
    for c in cs:
      (label, seq) = ('', [])
      for i in range(len(c['Choice'])):
        if i == 0:
          label = None if c['Choice'][0] == 'None' else c['Choice'][0]
#          label = c['Choice'][0]
#          if label == 'None':
#            label = None
        else:
          es = c['Choice'][i]
          r = toUxadtExpr(es)
          if r is not None:
            seq = seq + r
          else: break
      cb = cb + [Choice(label, AssocNone(), seq)]
    ps2 = ps2 + [Production(prodId, [Choices(cb)])]
  return Grammar(ps2)

def toUxadtExpr(es):
  if type(es) == str: 
    return [Terminal(es)]

  cs = []
  ty = list(es.keys())[0]
  x = es[ty][0]

  if ty == 'Comment':
    while x[0] == '#' or x[0].isspace():
      x = x[1:]
    if x[-1] == '\n':
      x = x[:-1]
    cs = cs + [Comment(x)]
  elif ty == 'Terminal':
    if len(x) == 3 and x[0] == '\"' and x[-1] == '\"':
      x = x[1]
    cs = cs + [Terminal(x)]
  elif ty == 'Empty String':
    cs = cs + [Terminal('\"\"')]
  elif ty == 'Nonterminal':
    cs = cs + [Nonterminal(x[1:])]
  elif ty == 'RegExpr':
    x = '/' + x[1:-1] + '/'
    cs = cs + [RegExpr(x)]
  # One/May/Many/MayMany
  elif ty == 'One':
    cs = cs + [One(toUxadtExpr(x))]
  elif ty == 'May':
    m = []
    for e in es[ty]:
      m = m + toUxadtExpr(e)
    cs = cs + [May(m)]
  elif ty == 'Many':
    m = []
    for e in es[ty]:
      m = m + toUxadtExpr(e)
    cs = cs + [Many(m)]
  elif ty == 'MayMany':
    m = []
    for e in es[ty]:
      m = m + toUxadtExpr(e)
    cs = cs + [MayMany(m)]
  # Group
  elif ty == 'Group':
    for e in es[ty]:
      cs = cs + toUxadtExpr(e)

  return cs


#######################################################
# Writes a UxADT grammar to a file.

def writeUxadt(u, name = 'gen', indent = 2):
  s = uxadtToStr(u, indent)
  f = open(name + '.py', 'w')
  f.write(
'''
##########################################
##
##  UxADT grammar generated by Imparse.
##
##########################################

'''
)
  f.write(name + 'Uxadt = ')
  f.write(s)
  f.close()

def uxadtToStr(u, indent = 2):
  indent = ' ' * indent
  ps = u.match(Grammar(_), lambda ps: ps).end
  st = 'Grammar([\\'
  for p in ps:
    (nt, cbs) = p.match(Production(_, _), lambda nt, cbs: (nt, cbs)).end
    st = st + '\n' + indent + 'Production(\'' + nt + '\', [\\'
    for cb in cbs:
      cs = cb.match(Choices(_), lambda cs: cs).end
      st = st + '\n' + (indent * 2) + 'Choices([\\'
      for c in cs:
        (label, seq) = c.match(Choice(_, _, _), lambda l, a, seq: (l, seq)).end
        if label is None:
          st = st + '\n' + (indent * 3) + 'Choice(None, AssocNone(), [\\'
        else:
          st = st + '\n' + (indent * 3) + 'Choice(\'' + label + '\', AssocNone(), [\\'
        r = uxadtSeqToStr(seq)
        st = st + '\n' + (indent * 4) + r + '\\\n' + (indent * 4) + ']),\\'
      st = st + '\n' + (indent * 3) + ']),\\'
    st = st + '\n' + (indent * 2) + ']),\\'
  st = st + '\n'+ indent + '])'
  return st

def uxadtSeqToStr(seq):
  s = ''
  for x in seq: 
    if x < One(_):
      (expr,) = x
      r = uxadtSeqToStr(expr)
      s = s + 'One([' + r + ']), '
    elif x < May(_):
      (expr,) = x
      r = uxadtSeqToStr(expr)
      s = s + 'May([' + r + ']), '
    elif x < Many(_):
      (expr,) = x
      r = uxadtSeqToStr(expr)
      s = s + 'Many([' + r + ']), '
    elif x < MayMany(_):
      (expr,) = x
      r = uxadtSeqToStr(expr)
      s = s + 'MayMany([' + r + ']), '
    elif x < Terminal(_):
      (expr,) = x
      s = s + 'Terminal(\'' + expr + '\'), '
    elif x < RegExpr(_):
      (expr,) = x
      s = s + 'RegExpr(\'' + expr + '\'), '
    elif x < Nonterminal(_):
      (expr,) = x
      s = s + 'Nonterminal(\'' + expr + '\'), '
  return s
  

##eof